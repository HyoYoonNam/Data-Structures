# ch01-03

source.c → pre-compile(전처리, #include 등의 처리) → compile → source.obj → build → link → Hello.exe

> link에서는 라이브러리 등을 가져온다(이 행위를 link라고 함).
> 

# ch01

12, 13, 17~19, 29~31, 35~실습

## 1. 프로그래밍 언어의 분류

- machine language
- assembly language
    
    승강기, 머신 등 임베디드에 사용
    
- high-level language
    
    C 등
    

## 2. C언어의 특징

- 저수준과 고수준이 모두 가능하다.
    
    윈도우 앱도 만들 수 있고 임베디드도 가능
    
- 이식성이 뛰어나다.
    
    어떤 os에서 만든 소스코드가 mac, linux, windows 모두에서 바로 사용 가능
    
- 결론: C는 Powerful하다(교수님 판서).

## 3. solution, project

MS Word는 solution. 각 기능은 project.

![Untitled](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled.png)

![솔루션 ‘Hello’ 하위에 Hello Project가 있음](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%201.png)

솔루션 ‘Hello’ 하위에 Hello Project가 있음

## 4. source file

프로젝트 내에 소스파일은 여러 개가 있어도 되지만, 그 중 main 함수는 하나여야만 핸다.

![Hello2.c와 test.c에 둘 다 main이 존재할 때 발생하는 에러. LNK1169](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%202.png)

Hello2.c와 test.c에 둘 다 main이 존재할 때 발생하는 에러. LNK1169

![Untitled](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%203.png)

실행을 위해서는 

1. source file을 executable file로 만드는 compile(Ctrl + F7)이 필요하다.
    
    이때 compile 결과는 .obj파일(01001..)
    
    *compile: 관련된 것들을 모으는 것
    
    ![compile complete.](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%204.png)
    
    compile complete.
    
    ![source.obj  created.](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%205.png)
    
    source.obj  created.
    
2. compile 후에는 link가 필요하다. by build(F7)
    
    build는 complie과 link를 모두 해준다.
    
    *link: 모은 것들을 연결시키는 것
    
    ![build complete.](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%206.png)
    
    build complete.
    
    ![Hello.exe created.](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%207.png)
    
    Hello.exe created.
    
    ![terminal에서 실행 가능](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%208.png)
    
    terminal에서 실행 가능
    
3. compile, link, 실행까지 모두 할 수 있는 방법도 있다. by 디버깅하지 않고 시작(Ctrl + F5)
    
    ![Untitled](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%209.png)
    

# ch02

절차지향언어는 function으로 구성되어 있다.

## 1. 예제 분석

각 문장을 statement라고 하고, `;`으로 끝낸다.

```c
#include <stdio.h>

int main(void) //리턴값을 int로 정의, parameter는 void
{
    printf("Hello World!"); //stdinput을 console로 출력하는 함수
    return 0; //return의 목적지는 OS
              //종료한다는 것은 제어가 OS로 넘어감을 의미
}
```

### 2. 만약 line 1을 comment처리 한다면

<aside>
💡 사전적 의미로는 주석이 annotation이지만, 개발에서는 comment라고 한다. 본래 comment에는 주석이라는 의미는 없다.

</aside>

by `Ctrl+K` + `Ctrl+C`

![Untitled](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%2010.png)

다음 두 사진을 보면 compile은 성공했지만 link에서 막힘을 알 수 있다.

![compile성공](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%2011.png)

compile성공

![build(=compile+link)실패 즉, link 실패.](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%2012.png)

build(=compile+link)실패 즉, link 실패.

`fatal error LNK1120: 1개의 확인할 수 없는 외부 참조입니다.`

`stdio.h`를 include하지 않았기 때문에 `printf`를 사용할 수 없기 때문에 발생하는 에러

### 3. #include

![Untitled](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%2013.png)

## 2. solution에 2개의 project 만들기

`Ctrl + Shift + N`으로 새 프로젝트 생성

![현재 Hello project가 bold인데 이는 active project임을 의미한다.](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%2014.png)

현재 Hello project가 bold인데 이는 active project임을 의미한다.

```c
/* 첫 번째 프로그램의 응용 */
#include <stdio.h>

int main(void)
{
	printf("Hello World1!");
	printf("from ChulSoo");
	return 0;
}
```

![‘1’이 출력되지 않음](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%2015.png)

‘1’이 출력되지 않음

‘!’가 출력되지 않은 이유는 active project가 Hello이기 때문이다.

![active project를 Hello1로 변경하고 실행하니 정상적으로 ‘!’가 출력됨](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%2016.png)

active project를 Hello1로 변경하고 실행하니 정상적으로 ‘!’가 출력됨

## 3. ‘Add’ project

이 경우에는 새 항목(Ctrl+Shift+A)이 아닌 기존 항목(Shift+Alt+A)으로 추가한다.

![Shift + Alt + A로 기존 항목(add1.c)을 추가함(사캠에 있는 파일)](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%2017.png)

Shift + Alt + A로 기존 항목(add1.c)을 추가함(사캠에 있는 파일)

```c
#include <stdio.h>

int main(void)
{
	int x;		
	int y;		
	int sum;	

	x = 100;
	y = 200;

	sum = x + y;
	printf("두수의 합 = %d \n", sum);

	return 0;
}
```

`int` 등과 같이 색이 있는 경우 **keyword(reserved word)**라고 함

`int`는 **4byte**

variable과 constant. constant에는 literal constant와 constant가 있음.

| format specifier | notes. |
| --- | --- |
| %d | decimal |
| %x | hexadecimal |
| %c | character |
| %s | string |
| %f | float |
| %lf | double |

만약 format specifier를 `%x`로 사용하면 다음과 `300`이 `0x12c`로 출력된다.

![variable naming을 잘못한 경우의 에러. `int x;`를 `int 1x;`로 수정함.](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/af48a465-a836-46be-9f60-3eb8e7ac2be6.png)

variable naming을 잘못한 경우의 에러. `int x;`를 `int 1x;`로 수정함.

## 4. ‘Add2’ project

```c
// 사용자로부터 입력받은 정수 2개의 합을 계산하여 출력
//비주얼 스튜디오 사용자라면 다음 문장이 필요하다.
//그 이유는 scanf 함수는 보안상 문제로 사용을 지양하도록 유도하기 위해서 컴파일 에러를 발생시킴
//define을 통해서 해당 에러를 무시하도록 pre-comfile함
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main(void)
{
	int x;				// 첫 번째 정수를 저장할 변수
	int y;				// 두 번째 정수를 저장할 변수
	int sum;				// 2개의 정수의 합을 저장할 변수

	printf("첫 번째 숫자를 입력하시오:");	// 입력 안내 메시지 출력
	scanf("%d", &x);			// 하나의 정수를 받아서 x에 저장

	printf("두 번째 숫자를 입력하시오:");	// 입력 안내 메시지 출력
	scanf("%d", &y);			// 하나의 정수를 받아서 x에 저장

	sum = x + y;			// 변수 2개를 더한다.
	printf("두수의 합= %d \n", sum);	// sum의 값을 10진수 형태로 출력

	return 0;			// 0을 외부로 반환
}
```

`scanf()`는 console로부터 값을 받아들인다.

`&`는 ampersand라고 한다. `&x`는 **x의 address**를 추출함

- x의 주소 확인하기 by debugging
    
    [[C99] gets_s() 함수, 디버깅을 통한 메모리 구조 알아보기](https://www.notion.so/C99-gets_s-0c6e38dd72ad41b989f776acc0fee7fd?pvs=21) 
    
    디버깅에서 메모리 화면은 `Alt + 6`으로 띄울 수 있다.
    
    ![y에 대해서 57 0b 70 96 …에 할당됨을 알 수 있다.](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%2018.png)
    
    y에 대해서 57 0b 70 96 …에 할당됨을 알 수 있다.
    

# ch03

## 1. data type

![Untitled](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%2019.png)

기본적으로 `int`, `double`, `char` 사용

```c
//declare
char c;
int i;
double interest_rate;
//initialize
char c = 'a';
int i = 7;
double interest_rate = 0.05;
```

## 2. size of each data type

![signed, unsigned. 맨 앞 bit는 sign bit이다(0 or 1). 이때 unsigned의 경우에는 sign bit가 필요 없으므로 2개의 경우의 수가 더 생기기 때문에 signed에 비해 2배 만큼 저장 양수 더 저장 가능](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%2020.png)

signed, unsigned. 맨 앞 bit는 sign bit이다(0 or 1). 이때 unsigned의 경우에는 sign bit가 필요 없으므로 2개의 경우의 수가 더 생기기 때문에 signed에 비해 2배 만큼 저장 양수 더 저장 가능

### sizeof()

```c
int x = 10;
printf("변수 x의 크기: %d\n", sizeof(x)); //int는 기본으로 4byte를 갖는다.
```

## 3. floating point

[04. CPU 수준의 data type](https://www.notion.so/04-CPU-data-type-920bf4dbdbd24e7eb46b0055bcf6a2af?pvs=21) 

`double d = 1.2345e2` is 1.2345 * 10^2 이때, 1.2345는 ‘가수부’, e2는 ‘지수부’라고 한다.

12345 십진수는 부동소수점 1.2345 * 10^4로 표현할 수 있다.

![부동소수점의 오버플로우는 특별하다.
x: 부동 소수점의 경우, 오버플로우가 발생하면 컴파일러는 해당 변수에 무한대를 의미하는 특별한 값을 대입한다.](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%2021.png)

부동소수점의 오버플로우는 특별하다.
x: 부동 소수점의 경우, 오버플로우가 발생하면 컴파일러는 해당 변수에 무한대를 의미하는 특별한 값을 대입한다.

## 4. string

![Untitled](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%2022.png)

위 그림에서 char Kc에는 ‘a’라는 문자가 할당되었다. 52는 ASCII

## 5. ASCII

7bit를 사용하여 알파벳을 표현(8bit 중 첫 bit는 다른 곳에 사용됨). 즉 decimal 0 ~ 127까지 매핑. 보통은 hexadecimal로 표현 0x0 ~ 0x7F

![Untitled](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%2023.png)

- Hex 0 to 7, 14 to 31은 Control Character. 제어 문자.
- Hex 9 to 13은 Whitespace. 공백 문자.

![Untitled](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%2024.png)

### 예제 ch03. p.82 char to ASCII

```c
#include <stdio.h>

int main(void)
{
	char c;		// 변수 선언

	c = 'A';		// 변수 c에 문자 'A'를 저장한다.
	printf("A의 아스키 코드= %d\n", c);	// 문자와 아스키코드를 출력

	c = 66;
	printf("아스키 코드 66에 매핑된 문자= %c\n", c);

	printf("문자를 입력하시오: ");	// 입력 안내문
	c = getchar();		// scanf("%c", &c)하여도 된다. 

	printf("%c의 아스키 코드= %d\n", c, c);	// 문자와 아스키코드를 출력
	return 0;
}
```

`getchar()`, `printf()` 등은 compiler 제작자들이 만든 함수

정수형 4byte, 실수형 8byte, 문자형 1byte(엄밀히는 7bit)

### NULL과 SP

0x00은 NUL, 0x20은 SP이다.

| NUL | NULL | 0x00 | 0(10) |
| --- | --- | --- | --- |
| SP | SPACE | 0x20 | 32(10) |

![Untitled](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%2025.png)

디버그시 F11은 한 단계씩 실행, F10은 프로시저 단위 실행(=함수 단위 실행. 단, breakpoints 존재시 break)

프로시저 단위 실행이라는 것은 만약 calculate 등의 함수를 실행해야될 때 함수 내부로 들어가지 않고(즉, 호출한 함수의 내부 코드에 대해서는 디버그를 진행하지 않고 함수를 호출만 함) 디버그를 이어가는 것을 의미한다.

https://blog.naver.com/PostView.naver?blogId=sharonichoya&logNo=220526812365

![1. declare 후 initialize하지 않은 상태라 쓰레기 값 저장됨](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%2026.png)

1. declare 후 initialize하지 않은 상태라 쓰레기 값 저장됨

![2. 65로 initialize](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%2027.png)

2. 65로 initialize

![3. ](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%2028.png)

3. 

![4. 이때 NUL의 경우 escape sequence(\0)에도 할당되어 있기 때문에 로컬값에 같이 띄워줌.](ch01-03%205cf1be1c02214f53bcedc14fa04edcf0/Untitled%2029.png)

4. 이때 NUL의 경우 escape sequence(\0)에도 할당되어 있기 때문에 로컬값에 같이 띄워줌.